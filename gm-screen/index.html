<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voidlight GM Screen - Coming Soon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
            color: #e0e0e0;
            background: #0a0f23;
        }

        /* Starfield Container */
        #starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* Content Overlay */
        .content-wrapper {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .container {
            max-width: 800px;
            text-align: center;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 20px;
            padding: 4rem 3rem;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #a78bfa 0%, #ec4899 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(167, 139, 250, 0.3);
        }

        .subtitle {
            font-size: 1.5rem;
            color: #94a3b8;
            margin-bottom: 2rem;
        }

        .description {
            font-size: 1.1rem;
            color: #cbd5e1;
            line-height: 1.8;
            margin-bottom: 3rem;
        }

        .back-button {
            display: inline-block;
            padding: 1rem 2.5rem;
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);
            color: white;
            text-decoration: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .icon {
            font-size: 5rem;
            margin-bottom: 2rem;
            display: block;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .subtitle {
                font-size: 1.2rem;
            }
            
            .container {
                padding: 3rem 2rem;
            }
        }
    </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
    <canvas id="starfield"></canvas>
    
    <div class="content-wrapper">
        <div class="container">
            <span class="icon">üé≤</span>
            <h1>GM Screen</h1>
            <p class="subtitle">Coming Soon</p>
            <p class="description">
                The Voidlight GM Screen is currently under development. This powerful tool will provide 
                game masters with quick reference tables, NPC generators, encounter builders, and 
                campaign management features to enhance your Voidlight sessions.
            </p>
            <a href="../" class="back-button">‚Üê Back to Tools</a>
        </div>
    </div>

    <script>
        // Starfield Configuration
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');
        
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        // Star and Planet Arrays
        const stars = [];
        const planets = [];
        const numStars = 800;
        
        // Speed control
        let baseSpeed = 2;
        let currentSpeed = baseSpeed;
        let targetSpeed = baseSpeed;
        
        // Scroll tracking
        let lastScrollY = window.scrollY;
        
        // Star class
        class Star {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * width - width / 2;
                this.y = Math.random() * height - height / 2;
                this.z = Math.random() * 1500;
                this.prevX = this.x;
                this.prevY = this.y;
            }
            
            update(speed) {
                this.prevX = this.x;
                this.prevY = this.y;
                
                this.z -= speed;
                
                if (this.z <= 0) {
                    this.reset();
                    this.z = 1500;
                }
            }
            
            draw() {
                const x = (this.x / this.z) * 200 + width / 2;
                const y = (this.y / this.z) * 200 + height / 2;
                const prevX = (this.prevX / this.z) * 200 + width / 2;
                const prevY = (this.prevY / this.z) * 200 + height / 2;
                
                if (x < 0 || x > width || y < 0 || y > height) {
                    this.reset();
                    return;
                }
                
                const size = (1 - this.z / 1500) * 3;
                const hue = 270 + Math.random() * 30;
                const brightness = 50 + (1 - this.z / 1500) * 50;
                
                ctx.strokeStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                ctx.lineWidth = size;
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                if (size > 2) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${hue}, 100%, ${brightness}%)`;
                    ctx.fillStyle = `hsl(${hue}, 100%, ${brightness}%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        // Planet types with realistic characteristics
        const planetTypes = [
            { name: 'Rocky', color: [180, 30, 25], features: 'craters', atmosphere: false },
            { name: 'Venus', color: [40, 60, 50], features: 'smooth', atmosphere: true },
            { name: 'Earth', color: [200, 50, 50], features: 'continents', atmosphere: true },
            { name: 'Mars', color: [15, 60, 45], features: 'craters', atmosphere: false },
            { name: 'Jupiter', color: [30, 40, 55], features: 'bands', atmosphere: true },
            { name: 'Saturn', color: [40, 30, 60], features: 'bands', atmosphere: true },
            { name: 'Uranus', color: [180, 40, 60], features: 'smooth', atmosphere: true },
            { name: 'Neptune', color: [220, 50, 50], features: 'smooth', atmosphere: true }
        ];
        
        // Planet class
        class Planet {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.z = 500 + Math.random() * 1000;
                this.type = planetTypes[Math.floor(Math.random() * planetTypes.length)];
                this.baseSize = 30 + Math.random() * 70;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.002;
            }
            
            update(speed) {
                this.z -= speed * 0.3;
                this.rotation += this.rotationSpeed;
                
                if (this.z <= 0) {
                    this.reset();
                    this.z = 1500;
                }
            }
            
            draw() {
                const scale = 1 - this.z / 1500;
                const size = this.baseSize * scale;
                const x = this.x;
                const y = this.y;
                
                if (size < 5) return;
                
                const [hue, sat, light] = this.type.color;
                
                // Create radial gradient for 3D sphere effect
                const gradient = ctx.createRadialGradient(
                    x - size * 0.3, y - size * 0.3, size * 0.1,
                    x, y, size
                );
                
                gradient.addColorStop(0, `hsl(${hue}, ${sat}%, ${light + 40}%)`);
                gradient.addColorStop(0.5, `hsl(${hue}, ${sat}%, ${light}%)`);
                gradient.addColorStop(1, `hsl(${hue}, ${sat}%, ${light - 40}%)`);
                
                // Draw planet body
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw surface features
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = 0.3;
                
                if (this.type.features === 'craters') {
                    for (let i = 0; i < 5; i++) {
                        const cx = (Math.random() - 0.5) * size * 1.5;
                        const cy = (Math.random() - 0.5) * size * 1.5;
                        const cr = size * 0.1 + Math.random() * size * 0.15;
                        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light - 20}%)`;
                        ctx.beginPath();
                        ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type.features === 'bands') {
                    for (let i = -3; i <= 3; i++) {
                        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light + (i % 2) * 10}%)`;
                        ctx.fillRect(-size, i * size / 4, size * 2, size / 4);
                    }
                } else if (this.type.features === 'continents') {
                    ctx.fillStyle = `hsl(120, 40%, 35%)`;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc((Math.random() - 0.5) * size, (Math.random() - 0.5) * size, 
                               size * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
                
                // Draw terminator (day/night shadow)
                const shadowGradient = ctx.createRadialGradient(
                    x + size * 0.3, y, size * 0.1,
                    x, y, size
                );
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                shadowGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.3)');
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
                
                ctx.fillStyle = shadowGradient;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw atmospheric glow (only for planets with atmosphere)
                if (this.type.atmosphere) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `hsl(${hue}, ${sat}%, ${light}%)`;
                    ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.3)`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        // Initialize stars
        for (let i = 0; i < numStars; i++) {
            stars.push(new Star());
        }
        
        // Initialize planets (3-5 planets)
        const numPlanets = 3 + Math.floor(Math.random() * 3);
        for (let i = 0; i < numPlanets; i++) {
            planets.push(new Planet());
        }
        
        // Add new planet periodically
        setInterval(() => {
            if (planets.length < 8) {
                planets.push(new Planet());
            }
        }, 15000);
        
        // Handle scroll-based parallax
        window.addEventListener('scroll', () => {
            const scrollY = window.scrollY;
            const scrollDelta = scrollY - lastScrollY;
            const scrollSpeed = Math.abs(scrollDelta);
            
            if (scrollSpeed > 0) {
                targetSpeed = baseSpeed + Math.min(scrollSpeed * 0.1, 3);
            } else {
                targetSpeed = baseSpeed;
            }
            
            lastScrollY = scrollY;
        });
        
        // Animation loop
        function animate() {
            // Smooth speed transition
            currentSpeed += (targetSpeed - currentSpeed) * 0.1;
            
            // Gradually return to base speed
            if (Math.abs(window.scrollY - lastScrollY) < 1) {
                targetSpeed += (baseSpeed - targetSpeed) * 0.05;
            }
            
            ctx.fillStyle = 'rgba(10, 15, 35, 0.2)';
            ctx.fillRect(0, 0, width, height);
            
            // Update and draw planets
            planets.forEach(planet => {
                planet.update(currentSpeed);
                planet.draw();
            });
            
            // Update and draw stars
            stars.forEach(star => {
                star.update(currentSpeed);
                star.draw();
            });
            
            requestAnimationFrame(animate);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>